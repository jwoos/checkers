# NYU CS-UY 4613 (Artificial Intelligence) Project
Minimax with Alpha-Beta Pruning in Checkers

## Build
You must have `go` installed as well as `dep`.

Built with the following:

```shell
% go version
go version go1.10 linux/amd64

% dep version
dep:
 version     : v0.4.1
 build date  : 2018-01-24
 git hash    : 37d9ea0a
 go version  : go1.9.1
 go compiler : gc
 platform    : linux/amd64
```

Refer to the following for installation:

- https://golang.org/doc/install
- https://github.com/golang/dep

You must also get a tool before continuing:

```
go get -v -u github.com/asticode/go-astilectron-bundler/...
```
This should drop in an executable at `$GOPATH/bin` called `astilectron-bundler`.

Now you can build the actual application.

1. Move the directory to your `$GOPATH`

```shell
% mkdir -p $GOPATH/src/
# assuming directory is called project
% mv project $GOPATH/src/
```

2. Move to the directory

```shell
cd $GOPATH/src/project
```

3. Pull down the dependency

```shell
% dep ensure
```

4. Run the bundler (this is required to build at all as it will generate embedded binary data as well as some missing methods)
   - This step only has to be run once unless the data that gets embedded changes (which it won't since you will be just building and not modifying)

```shell
% $GOPATH/bin/astilectron-bundler -v && chmod +x 
```

5. [OPTIONAL] Build it - this should place an executable in your directory with the same name as the directory

```shell
% go build
```

4. Run it
   - Linux: `build/linux-amd64/Checkers`
   - MacOS: `build/darwin-amd64/Checkers`
   - Windows: `build/windows-amd64/Checkers`

```shell
# again assuming the directory was called project and that you're going to run it on the current commputer
% ./project
# OR for bundled packages for different operating systems (tested only on Linux)
% ./build/linux-amd64/Checkers 
```

## Running

As stated above, there are several different outputs you can use. First and foremost is the output generated by `go build`. This will place an executable in the directory with name corresponding to the directory's name e.g. if you are in `project` and build it then it will result in an executable called `project` inside the `project` directory. This will be specific to the machine you build it on.

You can also use the builds provided by the bundler, which bundles together a binary for Linux, Windows, and MacOS. This will be in `build/$OS-amd64/Checkers` where `$OS` is one of `linux`, `darwin`, or `windows`. Be sure to use the proper executable for the proper operating system.

It's recommended that you run the bundler first and then just use the output of `go build`.

### Flags

The executable will show the different options available.

```shell
% ./project --help
Usage of ./project:
  -debug
    	Debug mode
  -depth int
    	Depth of minimax (default 16)
  -difficulty int
    	Difficulty indicated from 1 - 3 with 3 being the hardest (default 3)
  -first uint
    	Who should go first, 2 for human and 1 for ai (default 2)
  -gui
    	Initialize with a GUI
  -logger-app-name string
    	the logger's app name
  -v	if true, then log level is debug

```

## Design

I decided to split the work up into two pieces - a checkers engine that has all the necessary structures and methods to run a game as well as the actual driver program with the AI.

### go_checkers 

This is located at: https://github.com/jwoos/go_checkers

The main structure of this package is `StateByte` which keeps track of the game state as a 2D matrix of `byte`s which represent pieces. The other key structure is `Rule` which defines the ruleset for the game - I made it this way as I wanted a reusable checkers engine but the assignment deviated from the standard rules of checkers. The other files were implemented to be used for a full game of checkers: `StateByte` and `State` are almost identical except the former uses a 2D matrix of `byte`s for the game board while the latter uses `Piece`s.

`StateByte` has various methods associated with it that help drive a game. For instance it can get all the possible moves for a current side by `PossibleMovesAll`. It can also return only the possible moves for a given piece with `PossibleMoves`. It has analogous functions to return only capture moves in the forms of `PossibleCaptureMoves` and `PossibleCaptureMovesAll`.

`StateByte` is also capable of doing error checks and checking if the game has ended. This basically takes care of all the minute details of actually playing a chess game from moving a piece to validating that a move is correct. It also implements the `Stringer` interface for pretty printing out the game state.

### Driver

This is the driver of the actual program. At its core, it takes the checkers package and makes use of it to run an actual game. It's further divided into two sections: GUI and CLI. The main package just parses some flags and decides to either run the GUI or CLI version.

#### CLI

The CLI game is just a loop going between human and AI. Before each move, it checks if either the game has ended or the player has no moves left.

#### GUI

The GUI version is actually an electron application using astilectron which aims to simplify things a bit. Essentially the electron GUI is the client and the Go application is the server. It then falls to passing messages between the two via an internal HTTP call. The GUI does no calculations of its own meaning that everything is offloaded to the server since everything was being done there anyways. After each move, it's checked whether the game has ended or whether the player has no moves left.

The JavaScript code is just simple rendering code, to take the state of the game and just display it.

## Heuristics

## Terminal

- 0: There was a tie
- -100: Min player has won
- 100: Max player has won

### Levels

#### 1

The easiest level just takes the difference in the number of pieces between the two players. This allows each player to respectively minimize the other player's piece count while maximizing their own piece count. This makes sense as a game is over when one player has no more pieces remaining.
$$
max = pieces_{max} - pieces_{min} \\
min = -(pieces_{min} - pieces_{max})
$$

#### 2

The second level takes into account the moves while also looking at the number of possible moves. This is also important since there are occasions where a move might not be capturing but might just set up for a better state. It's also important as a player loses when they have no more possible moves left. Although the two metrics are used together, a greater weight was given to the number of pieces which also correlates with the number of moves left.
$$
max = 10 * (pieces_{max} - pieces_{min}) + 5 * (moves_{max} - moves_{min}) \\
min = -(10 * (pieces_{min} - pieces_{max}) + 5 * (moves_{min} - moves_{max}))
$$

#### 3

The third level extends the second level further. It takes into account how many of your own pieces are actually safe from capture. This is important as it indicates just what kind of position you might be in as opposed to your opponent. The move in turn will lead to a capture which lowers the opponent piece count, tilting the game in your favor. Again, it was weight against the total number of pieces based on how important it seems.
$$
max = 15 * (pieces_{max} - pieces_{min}) + 5 * (moves_{max} - moves_{min} + 5 * (safe_{max} - safe_{min})) \\
min = -(15 * (pieces_{min} - pieces_{max}) + 5 * (moves_{min} - moves_{max}) + 5 * (safe_{min} - safe_{max}))
$$


#### Note

- In all of these, I chose to take the difference for each metric as this is a zero sum game where one player benefits from the loss of the other.
- The weight was determined through trial and error as well as what seems to make sense. The count seemed the most important as it would be impossible to get through a game without capturing pieces which meant that most matches would be determined by piece count. The other evaluation function pieces merely help it perform a bit better than just trying to capture everything including positioning and safety of own pieces.
- The algorithm was very aggressive, frequently offering up its own pieces for capture which in turn would allow them to do another capture. I believe this was due to the count of pieces but wasn't sure how to make it a bit more neutral.
- At times the algorithm sacrifices pieces even though there were other viable moves which would have saved the piece from being captured for the foreseeable future.